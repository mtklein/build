#!/usr/bin/env python3

import collections
import glob
import graphlib
import os
import subprocess
import sys

sys.stdout = open('build.ninja', 'w')

print('''
builddir = out

rule compile
  command = $cc -g -O1 -Werror -fdiagnostics-color -MD -MF $out.d -c $in -o $out
  depfile = $out.d
  deps    = gcc

rule link
  command = $cc $in -o $out

rule run
  command = $runtime ./$in > $out
''')

modes = {}
for pat in [ '/usr/bin/clang'
           , '/opt/homebrew/bin/zig'
           , '/opt/homebrew/opt/gcc/bin/gcc-[0-9][0-9]'
           , '/opt/homebrew/opt/llvm/bin/clang-[0-9][0-9]'
           ]:
    for cmd in glob.glob(pat):
        name = os.path.basename(cmd)
        flags = [ '-Weverything'
                , '-Wno-declaration-after-statement'
                , '-Wno-poison-system-directories'
                , '-Wno-pre-c11-compat'
                , '-Wno-unknown-warning-option'
                , '-Wno-unsafe-buffer-usage'
                ] if 'clang' in name or 'zig' in name else ['-Wall', '-Wextra']
        if 'zig' in name:
            cmd = f'{cmd} cc'
        print(f'{name} = {cmd} {" ".join(flags)}')
        modes[name] = ''

print('''
leak = $clang
asan = $clang -fno-sanitize-recover=all -fsanitize=address,integer,undefined
tsan = $clang -fno-sanitize-recover=all -fsanitize=thread
lto  = $clang -flto
x86  = $clang -arch x86_64 -arch x86_64h
wasm = $zig -target wasm32-wasi -msimd128
''')
# TODO: test failures don't cause leaks to fail.  If fixed, $leak can fold back into $clang.
modes.update(leak='leaks -quiet -noContent --atExit --',
             asan='', tsan='', lto='', x86='', wasm='wasmer')

srcs = subprocess.run(['git', 'ls-files', '*.c']    ,stdout=subprocess.PIPE).stdout.decode().split()
main = subprocess.run(['git', 'grep', '-l', 'main('],stdout=subprocess.PIPE).stdout.decode().split()
rest = [src for src in srcs if src not in main]

for cc in modes:
    target = lambda src: f'out/{cc}/{os.path.splitext(src)[0]}'
    for src in srcs:
        print(f'build {target(src)}.o: compile {src}\n  cc=${cc}')

sys.stdout.flush()
rc = subprocess.call(['ninja'] + sys.argv[1:])
if rc != 0:
    sys.exit(rc)

owner = {}
for src in srcs:
    obj = os.path.splitext(src)[0] + '.o'
    for sym in subprocess.check_output(['nm', '-gjU', 'out/clang/' + obj]).splitlines():
        owner[sym] = obj

deps = collections.defaultdict(set)
for src in srcs:
    obj = os.path.splitext(src)[0] + '.o'
    for sym in subprocess.check_output(['nm', '-gju', 'out/clang/' + obj]).splitlines():
        if sym in owner:
            deps[obj].add(owner[sym])

for path in graphlib.TopologicalSorter(deps).static_order():
    indirect = set()
    for dep in deps[path]:
        indirect.update(deps[dep])
    deps[path].update(indirect)

for cc in modes:
    for src in main:
        target = f'out/{cc}/{os.path.splitext(src)[0]}'
        objs = [f'out/{cc}/' + dep for dep in sorted(deps[os.path.splitext(src)[0] + '.o'])]
        print(f'build {target}: link {target}.o {" ".join(objs)}\n  cc=${cc}\n')
        if 'test' in src:
            print(f'build {target}.ok: run {target}\n  runtime={modes[cc]}')

sys.stdout.close()
rc = subprocess.call(['ninja'] + sys.argv[1:])
if rc == 0:
    os.remove('build.ninja')
    subprocess.call(['git', 'add', '-u'])
sys.exit(rc)
